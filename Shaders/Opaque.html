<html>

<!--
*********************************************************
Shader name: Opaque
Description: Simple textured.
*********************************************************

*********
CHANGELOG
*********
Date: March 3rd, 2015
Description: Initial Implementation
Author: Joseph Cameron
    
-->
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<script id="Vertex">
    //***************
    // Vertex Formats
    //***************
    //VertIn
    attribute highp vec3 a_Pos    ;
    attribute lowp  vec2 a_UV     ;
    attribute lowp  vec3 a_Normal ;
    
    //FragIn
    varying lowp  vec2 v_UV          ;
    varying lowp  vec3 v_Normal      ;
    varying highp vec3 v_WorldNormal ;
    
    //*********
    // Uniforms
    //*********
    uniform highp float _Time;
    uniform mat4 _ModelScaleMatrix;
    uniform mat4 _ModelRotationMatrix;
    uniform mat4 _Object2WorldMatrix;
    uniform mat4 _ViewMatrix;
    uniform mat4 _ProjectionMatrix;
    
    //******************************
    // Vertex operation forward decs
    //******************************
    //vec4 rotateAroundZ(const vec4 aPos, const float aDegree);
    
    //**************
    // Vertex shader
    //**************
    void main()
    {
        //Calculate position
        highp vec4 position = vec4(a_Pos,1.0);
        {
            position *= _ModelScaleMatrix;
            position *= _ModelRotationMatrix;
            
            //Model space operations       
         
            //Spin
            //position = rotateAroundY(position,_Time);            
            
            //World space operations
            
            position = _Object2WorldMatrix * position;
            
           
            
            //Camera space operations
            position = _ViewMatrix * position;
            
            
            
            //Perspective space operations
            position = _ProjectionMatrix * position;
         
            
            
        }
        
        gl_Position = position;
        
        //Passthrough UV
        v_UV = a_UV;
        
        //Passthough Normal
        v_Normal = a_Normal;
        
        //Calc worldnormal
        highp vec4 worldNormal = vec4(a_Normal,1.0);
        {
            worldNormal *= _ModelScaleMatrix    ;
            //worldNormal = rotateAroundY(worldNormal,_Time);
            worldNormal *= _ModelRotationMatrix ;
            worldNormal *= _Object2WorldMatrix  ;
        
        }
        
        v_WorldNormal = vec3(worldNormal[0],worldNormal[1],worldNormal[2]);
        
        
        
    }
  
 </script>

<script id="Fragment">
    //Indicate byte size for float type
    precision mediump float;
    
    //*************************
    // FragmentIn vertex format
    //*************************
    varying lowp  vec2 v_UV          ;
    varying lowp  vec3 v_Normal      ;
    varying highp vec3 v_WorldNormal ;
    
    //*********
    // Uniforms
    //*********
    uniform lowp vec4 _Color;
    uniform sampler2D _Texture;
    
    //**********
    // Constants
    //**********
    const float c_AlphaCutOff = 1.0;
    
    //*********************************
    // Fragment operations forward decs
    //*********************************
    vec4 calculateDiffuseLighting(const vec4 aColor, const vec3 aNormal, const vec3 aLightPos, const vec4 aLightColor);
    vec4 calculateTexelColor(const vec4 aFrag);
    vec4 alphaCutOff(const vec4 aFrag);
    
    //*****************
    // Fragment shader
    //****************
    void main()
    {
        lowp vec4 rvalue = vec4(0);
        {
            rvalue = calculateTexelColor(rvalue);
            
            
            
            //Calculate diffuse color
            lowp vec4 lightColor   = vec4(1.0,1.0,1.0,1.0);
            mediump vec3 lightPos = vec3(0.5,1.0,2.0);
            rvalue = calculateDiffuseLighting(rvalue, v_WorldNormal, lightPos, lightColor);
            
            //rvalue = vec4(v_WorldNormal,1.0);
            
        }
    
        gl_FragColor = rvalue;
    
    }
    
    //*******************************
    //Fragment operations definitions
    //*******************************
    vec4 calculateDiffuseLighting(const vec4 aColor, const vec3 aNormal, const vec3 aLightPos, const vec4 aLightColor)
    {
        vec4 rvalue = aColor;
        {
            lowp vec3 normal   = normalize(aNormal);
            lowp vec3 lightDir = normalize(aLightPos);
            
            rvalue *= aLightColor*max(dot(normal,lightDir),0.05);

        }
        
        return rvalue;
    
    }
    
    vec4 calculateTexelColor(const vec4 aFrag)
    {
        vec4 rvalue = aFrag;
        {
            rvalue = texture2D(_Texture, v_UV);
            
        }
        
        return rvalue;      
        
    }
    
    vec4 alphaCutOff(const vec4 aFrag)
    {
        vec4 rvalue = aFrag;
        {
            if (rvalue[3] < c_AlphaCutOff)
                discard;  
                        
        }
        
        return rvalue;
        
    }
    
  </script>

</html>